#ifndef _MSDFGL_SHADERS_H
#define _MSDFGL_SHADERS_H

const char * _font_fragment = "\n"
"precision highp float;\n"
"in vec2 text_pos;\n"
"in vec4 text_color;\n"
"in float strength;\n"
"out vec4 color;\n"
"\n"
"uniform sampler2D font_atlas;\n"
"uniform mat4 font_projection;\n"
"\n"
"float median(float r, float g, float b) {\n"
"    return max(min(r, g), min(max(r, g), b));\n"
"}\n"
"float pxRange = 4.0;\n"
"\n"
"void main() {\n"
"    vec2 coords = (font_projection * vec4(text_pos, 0.0, 1.0)).xy;\n"
"\n"
"    /* Invert the strength so that 1.0 becomes bold and 0.0 becomes thin */\n"
"    float threshold = 1.0 - strength;\n"
"\n"
"    vec2 msdfUnit = pxRange/vec2(textureSize(font_atlas, 0));\n"
"    vec3 s = texture(font_atlas, coords).rgb;\n"
"    float sigDist = median(s.r, s.g, s.b) - threshold;\n"
"    sigDist *= dot(msdfUnit, 0.5/fwidth(coords));\n"
"    float opacity = clamp(sigDist + 0.5, 0.0, 1.0);\n"
"    color = mix(vec4(0.0, 0.0, 0.0, 0.0), text_color, opacity);\n"
"}";

const char * _font_geometry = "\n"
"layout (points) in;\n"
"layout (triangle_strip, max_vertices = 4) out;\n"
"\n"
"in VS_OUT {\n"
"    int glyph;\n"
"    vec4 color;\n"
"    float size;\n"
"    float y_offset;\n"
"    float skewness;\n"
"    float strength;\n"
"} gs_in[];\n"
"\n"
"out vec2 text_pos;\n"
"out vec4 text_color;\n"
"out float strength;\n"
"\n"
"uniform mat4 projection;\n"
"uniform float padding;\n"
"uniform float units_per_em;\n"
"uniform vec2 dpi;\n"
"\n"
"precision mediump samplerBuffer;\n"
"uniform samplerBuffer font_index;\n"
"\n"
"\n"
"void main() {\n"
"    text_color = gs_in[0].color;\n"
"    strength = gs_in[0].strength;\n"
"\n"
"    vec4 font_size = vec4(gs_in[0].size * dpi / 72.0 / units_per_em, 1.0, 1.0);\n"
"\n"
"    int _offset = 8 * gs_in[0].glyph;\n"
"    vec2 text_offset = vec2(texelFetch(font_index, _offset + 0).r,\n"
"                            texelFetch(font_index, _offset + 1).r);\n"
"    vec2 glyph_texture_width = vec2(texelFetch(font_index, _offset + 2).r, 0.0 );\n"
"    vec2 glyph_texture_height = vec2(0.0, texelFetch(font_index, _offset + 3).r);\n"
"\n"
"    vec4 bearing = vec4(texelFetch(font_index, _offset + 4).r,\n"
"                        -texelFetch(font_index, _offset + 5).r, 0.0, 0.0) * font_size;\n"
"\n"
"    vec4 glyph_width = vec4(texelFetch(font_index, _offset + 6).r, 0.0, 0.0, 0.0) * font_size;\n"
"    vec4 glyph_height = vec4(0.0, texelFetch(font_index, _offset + 7).r, 0.0, 0.0) * font_size;\n"
"\n"
"    vec4 padding_x = vec4(padding, 0.0, 0.0, 0.0) * font_size;\n"
"    vec4 padding_y = vec4(0.0, padding, 0.0, 0.0) * font_size;\n"
"    float skewness = gs_in[0].skewness;\n"
"\n"
"    vec4 p = gl_in[0].gl_Position + vec4(0.0, gs_in[0].y_offset, 0.0, 0.0);\n"
"    vec4 _p = p;\n"
"\n"
"\n"
"    // BL\n"
"    _p = p + bearing + glyph_height - padding_x + padding_y;\n"
"    _p.x += skewness * (p.y - _p.y);\n"
"    gl_Position = projection * _p;\n"
"    text_pos = text_offset + glyph_texture_height;\n"
"    EmitVertex();\n"
"\n"
"    // BR\n"
"    _p = p + bearing + glyph_height + glyph_width + padding_x + padding_y;\n"
"    _p.x += skewness * (p.y - _p.y);\n"
"    gl_Position = projection * _p;\n"
"    text_pos = text_offset + glyph_texture_width + glyph_texture_height;\n"
"    EmitVertex();\n"
"\n"
"    // TL\n"
"    _p = p + bearing - padding_x - padding_y;\n"
"    _p.x += skewness * (p.y - _p.y);\n"
"    gl_Position = projection * _p;\n"
"    text_pos = text_offset;\n"
"    EmitVertex();\n"
"\n"
"    // TR\n"
"    _p = p + bearing + glyph_width + padding_x - padding_y;\n"
"    _p.x += skewness * (p.y - _p.y);\n"
"    gl_Position = projection * _p;\n"
"    text_pos = text_offset + glyph_texture_width;\n"
"    EmitVertex();\n"
"\n"
"    EndPrimitive();\n"
"}";

const char * _font_vertex = "\n"
"layout (location = 0) in vec2 vertex;\n"
"layout (location = 1) in uvec4 glyph_color;\n"
"layout (location = 2) in int glyph_index;\n"
"layout (location = 3) in float size;\n"
"layout (location = 4) in float y_offset;\n"
"layout (location = 5) in float skewness;\n"
"layout (location = 6) in float strength;\n"
"\n"
"uniform mat4 projection;\n"
"\n"
"out VS_OUT {\n"
"    int glyph;\n"
"    vec4 color;\n"
"    float size;\n"
"    float y_offset;\n"
"    float skewness;\n"
"    float strength;\n"
"\n"
"} vs_out;\n"
"\n"
"void main() {\n"
"    gl_Position = vec4(vertex.xy, 0.0, 1.0);\n"
"    vs_out.glyph = glyph_index;\n"
"    uvec4 c = glyph_color;\n"
"    vs_out.color = vec4(float(c.a) / 255.0, float(c.b) / 255.0,\n"
"                        float(c.g) / 255.0, float(c.r) / 255.0);\n"
"    vs_out.size = size;\n"
"    vs_out.y_offset = y_offset;\n"
"    vs_out.skewness = skewness;\n"
"    vs_out.strength = strength;\n"
"}";

const char * _msdf_fragment = "\n"
"#define IDX_CURR 0\n"
"#define IDX_SHAPE 1\n"
"#define IDX_INNER 2\n"
"#define IDX_OUTER 3\n"
"#define IDX_RED 0\n"
"#define IDX_GREEN 1\n"
"#define IDX_BLUE 2\n"
"#define IDX_NEGATIVE 0\n"
"#define IDX_POSITIVE 1\n"
"#define IDX_MAX_INNER 0\n"
"#define IDX_MAX_OUTER 1\n"
"\n"
"\n"
"precision mediump float;\n"
"\n"
"precision mediump samplerBuffer;\n"
"precision mediump usamplerBuffer;\n"
"uniform usamplerBuffer metadata;\n"
"uniform samplerBuffer point_data;\n"
"\n"
"#define meta_at(i) texelFetch(metadata, int(i)).r\n"
"#define point_at(i) vec2(texelFetch(point_data, 2 * int(i)).r, \\\n"
"                         texelFetch(point_data, 2 * int(i) + 1).r)\n"
"\n"
"uniform vec2 offset;\n"
"\n"
"uniform vec2 translate;\n"
"uniform vec2 scale;\n"
"uniform float range;\n"
"uniform int meta_offset;\n"
"uniform int point_offset;\n"
"uniform float glyph_height;\n"
"\n"
"out vec4 color;\n"
"\n"
"const float PI = 3.1415926535897932384626433832795;\n"
"const float INFINITY = 3.402823466e+38;\n"
"\n"
"const uint BLACK = 0u;\n"
"const uint RED = 1u;\n"
"const uint GREEN = 2u;\n"
"const uint BLUE = 4u;\n"
"const uint YELLOW = RED | GREEN;\n"
"const uint MAGENTA = BLUE | RED;\n"
"const uint CYAN = BLUE | GREEN;\n"
"const uint WHITE = RED | GREEN | BLUE;\n"
"\n"
"struct segment {\n"
"    vec3 min_true;\n"
"    vec2 mins[2];\n"
"    int nearest_points;\n"
"    int nearest_npoints;\n"
"};\n"
"\n"
"struct workspace {\n"
"    segment segments[4 * 3];\n"
"\n"
"    vec3 maximums[2];\n"
"    vec3 min_absolute;\n"
"};\n"
"\n"
"workspace ws;\n"
"\n"
"vec3 signed_distance_linear(vec2 p0, vec2 p1, vec2 origin);\n"
"vec3 signed_distance_quad(vec2 p0, vec2 p1, vec2 p2, vec2 origin);\n"
"void add_segment_true_distance(int segment_index, int npoints, int points, vec3 d);\n"
"vec3 get_pixel_distance(vec2);\n"
"\n"
"vec2 orthonormal(vec2 v) {float len = length(v); return vec2(v.y / len, -v.x / len);}\n"
"float cross_(vec2 a, vec2 b) { return a.x * b.y - a.y * b.x; }\n"
"float median(vec3 d) {return max(min(d.r, d.g), min(max(d.r, d.g), d.b));}\n"
"void add_segment_pseudo_distance(int segment_index, vec2 d);\n"
"vec2 distance_to_pseudo_distance(int npoints, int points, vec3 d, vec2 p);\n"
"bool point_facing_edge(int prev_npoints, int prev_points, int cur_npoints, int cur_points,\n"
"                       int next_npoints, int next_points, vec2 p, float param);\n"
"void add_segment(int prev_npoints, int prev_points, int cur_npoints, int cur_points,\n"
"                 int next_npoints, int next_points, uint color, vec2 point);\n"
"void set_contour_edge(int winding, vec2 point);\n"
"float compute_distance(int segment_index, vec2 point);\n"
"\n"
"\n"
"bool less(vec2 a, vec2 b) {\n"
"    return abs(a.x) < abs(b.x) || (abs(a.x) == abs(b.x) && a.y < b.y);\n"
"}\n"
"\n"
"\n"
"void main() {\n"
"    vec2 coords = gl_FragCoord.xy - offset;\n"
"\n"
"    vec2 p = ((coords + 0.49) / scale) - vec2(translate.x, -translate.y);\n"
"    p.y  = (glyph_height / scale.y) - p.y;\n"
"\n"
"    ws.maximums[0].r = -INFINITY;\n"
"    ws.maximums[1].r = -INFINITY;\n"
"    ws.maximums[0].g = -INFINITY;\n"
"    ws.maximums[1].g = -INFINITY;\n"
"    ws.maximums[0].b = -INFINITY;\n"
"    ws.maximums[1].b = -INFINITY;\n"
"    ws.min_absolute.r = -INFINITY;\n"
"    ws.min_absolute.g = -INFINITY;\n"
"    ws.min_absolute.b = -INFINITY;\n"
"\n"
"    for (int i = 0; i < (4 * 3); ++i) {\n"
"        ws.segments[i].mins[0].x = -INFINITY;\n"
"        ws.segments[i].mins[1].x = -INFINITY;\n"
"        ws.segments[i].min_true.x = -INFINITY;\n"
"        ws.segments[i].nearest_points = -1;\n"
"    }\n"
"    int point_index = point_offset;\n"
"    int meta_index = meta_offset;\n"
"\n"
"\n"
"    uint ncontours = meta_at(meta_index++);\n"
"\n"
"    for (uint _i = 0u; _i < ncontours; ++_i) {\n"
"        int winding = int(meta_at(meta_index++)) - 1;\n"
"        uint nsegments = meta_at(meta_index++);\n"
"\n"
"        uint s_color = meta_at(meta_index);\n"
"        uint s_npoints = meta_at(meta_index + 1);\n"
"\n"
"        /** TODO: Move the following checks to the preprocessor, no need to do\n"
"                  them for every fragment. */\n"
"        /* Ignore empty contours. */\n"
"        if (nsegments == 0u) {\n"
"            continue;\n"
"        }\n"
"\n"
"        /* Ignore contours with just one linear segment, some fonts seem to have them. */\n"
"        if (nsegments == 1u && s_npoints == 2u) {\n"
"            point_index += 2;\n"
"            meta_index += 2;\n"
"            continue;\n"
"        }\n"
"\n"
"        /* Ignore contours with just two linear segments, some fonts seem to have them. */\n"
"        if (nsegments == 2u && s_npoints == 2u && meta_at(meta_index + 3) == 2u) {\n"
"            point_index += 4;\n"
"            meta_index += 4;\n"
"            continue;\n"
"        }\n"
"\n"
"        int cur_points = point_index;\n"
"        uint cur_color = meta_at(meta_index + 2 * (int(nsegments) - 1));\n"
"        uint cur_npoints = meta_at(meta_index + 2 * (int(nsegments) - 1) + 1);\n"
"\n"
"\n"
"        uint prev_npoints = nsegments >= 2u ?\n"
"            meta_at(meta_index + 2 * (int(nsegments) - 2) + 1) : s_npoints;\n"
"        int prev_points = point_index;\n"
"\n"
"        for (uint _i = 0u; _i < nsegments - 1u; ++_i) {\n"
"            uint npoints = meta_at(meta_index + 2 * int(_i) + 1);\n"
"            cur_points += (int(npoints) - 1);\n"
"        }\n"
"\n"
"        for (uint _i = 0u; (_i < (nsegments - 2u)) && nsegments >= 2u; ++_i) {\n"
"            uint npoints = meta_at(meta_index + 2 * int(_i) + 1);\n"
"            prev_points += (int(npoints) - 1);\n"
"        }\n"
"\n"
"        for (uint _i = 0u; _i < nsegments; ++_i) {\n"
"\n"
"            add_segment(int(prev_npoints), prev_points, int(cur_npoints), cur_points,\n"
"                        int(s_npoints), point_index, cur_color, p);\n"
"\n"
"            prev_points = cur_points;\n"
"            prev_npoints = cur_npoints;\n"
"\n"
"            cur_points = point_index;\n"
"            cur_npoints = s_npoints;\n"
"            cur_color = s_color;\n"
"\n"
"            s_color = meta_at(meta_index++ + 2);\n"
"            point_index += (int(s_npoints) - 1);\n"
"            s_npoints = meta_at(meta_index++ + 2);\n"
"        }\n"
"        point_index += 1;\n"
"\n"
"        set_contour_edge(winding, p);\n"
"    }\n"
"\n"
"    vec3 d = get_pixel_distance(p);\n"
"\n"
"    color = vec4(d / range + 0.5, 1.0);\n"
"\n"
"    // For testing\n"
"    // color = median(color.rgb) > 0.5 ? vec4(1.0, 1.0, 1.0, 1.0) : vec4(0.0, 0.0, 0.0, 1.0);\n"
"}\n"
"\n"
"void merge_segment(int s, int other) {\n"
"    if (less(ws.segments[other].min_true.xy, ws.segments[s].min_true.xy)) {\n"
"        ws.segments[s].min_true = ws.segments[other].min_true;\n"
"\n"
"        ws.segments[s].nearest_npoints = ws.segments[other].nearest_npoints;\n"
"        ws.segments[s].nearest_points = ws.segments[other].nearest_points;\n"
"    }\n"
"    if (less(ws.segments[other].mins[IDX_NEGATIVE], ws.segments[s].mins[IDX_NEGATIVE]))\n"
"        ws.segments[s].mins[IDX_NEGATIVE] = ws.segments[other].mins[IDX_NEGATIVE];\n"
"    if (less(ws.segments[other].mins[IDX_POSITIVE], ws.segments[s].mins[IDX_POSITIVE])) {\n"
"        ws.segments[s].mins[IDX_POSITIVE] = ws.segments[other].mins[IDX_POSITIVE];\n"
"    }\n"
"}\n"
"\n"
"void merge_multi_segment(int e, int other) {\n"
"    merge_segment(e * 3 + IDX_RED, other * 3 + IDX_RED);\n"
"    merge_segment(e * 3 + IDX_GREEN, other * 3 + IDX_GREEN);\n"
"    merge_segment(e * 3 + IDX_BLUE, other * 3 + IDX_BLUE);\n"
"}\n"
"\n"
"void add_segment(int prev_npoints, int prev_points, int cur_npoints, int cur_points,\n"
"                 int next_npoints, int next_points, uint s_color, vec2 point) {\n"
"\n"
"    vec3 d;\n"
"    if (cur_npoints == 2)\n"
"        d = signed_distance_linear(point_at(cur_points),\n"
"                                   point_at(cur_points + 1),\n"
"                                   point);\n"
"    else\n"
"        d = signed_distance_quad(point_at(cur_points),\n"
"                                 point_at(cur_points + 1),\n"
"                                 point_at(cur_points + 2),\n"
"                                 point);\n"
"\n"
"    if ((s_color & RED) > 0u)\n"
"        add_segment_true_distance(IDX_CURR * 3 + IDX_RED, cur_npoints, cur_points, d);\n"
"    if ((s_color & GREEN) > 0u)\n"
"        add_segment_true_distance(IDX_CURR * 3 + IDX_GREEN, cur_npoints, cur_points, d);\n"
"    if ((s_color & BLUE) > 0u)\n"
"        add_segment_true_distance(IDX_CURR * 3 + IDX_BLUE, cur_npoints, cur_points, d);\n"
"\n"
"    if (point_facing_edge(prev_npoints, prev_points, cur_npoints, cur_points,\n"
"                          next_npoints, next_points, point, d.z)) {\n"
"\n"
"        vec2 pd = distance_to_pseudo_distance(cur_npoints, cur_points, d, point);\n"
"        if ((s_color & RED) > 0u)\n"
"            add_segment_pseudo_distance(IDX_CURR * 3 + IDX_RED, pd);\n"
"        if ((s_color & GREEN) > 0u)\n"
"            add_segment_pseudo_distance(IDX_CURR * 3 + IDX_GREEN, pd);\n"
"        if ((s_color & BLUE) > 0u)\n"
"            add_segment_pseudo_distance(IDX_CURR * 3 + IDX_BLUE, pd);\n"
"    }\n"
"}\n"
"\n"
"vec3 get_distance(int segment_index, vec2 point) {\n"
"    vec3 d;\n"
"    d.r = compute_distance(segment_index * 3 + IDX_RED, point);\n"
"    d.g = compute_distance(segment_index * 3 + IDX_GREEN, point);\n"
"    d.b = compute_distance(segment_index * 3 + IDX_BLUE, point);\n"
"    return d;\n"
"}\n"
"\n"
"void set_contour_edge(int winding, vec2 point) {\n"
"\n"
"    vec3 d = get_distance(IDX_CURR, point);\n"
"\n"
"    merge_multi_segment(IDX_SHAPE, IDX_CURR);\n"
"    if (winding > 0 && median(d) >= 0.0)\n"
"        merge_multi_segment(IDX_INNER, IDX_CURR);\n"
"    if (winding < 0 && median(d) <= 0.0)\n"
"        merge_multi_segment(IDX_OUTER, IDX_CURR);\n"
"\n"
"    int i = winding < 0 ? IDX_MAX_INNER : IDX_MAX_OUTER;\n"
"\n"
"    ws.maximums[i] = (median(d) > median(ws.maximums[i])) ? d : ws.maximums[i];\n"
"    ws.min_absolute = (abs(median(d)) < abs(median(ws.min_absolute))) ? d : ws.min_absolute;\n"
"}\n"
"\n"
"vec2 segment_direction(int points, int npoints, float param) {\n"
"    return mix(point_at(points + 1) - point_at(points),\n"
"               point_at(points + npoints - 1) - point_at(points + npoints - 2),\n"
"               param);\n"
"}\n"
"\n"
"vec2 segment_point(int points, int npoints, float param) {\n"
"    return mix(mix(point_at(points), point_at(points + 1), param),\n"
"               mix(point_at(points + npoints - 2), point_at(points + npoints - 1), param),\n"
"               param);\n"
"}\n"
"\n"
"\n"
"vec2 distance_to_pseudo_distance(int npoints, int points, vec3 d, vec2 p) {\n"
"    if (d.z >= 0.0 && d.z <= 1.0)\n"
"        return d.xy;\n"
"\n"
"    vec2 dir = normalize(segment_direction(points, npoints, d.z < 0.0 ? 0.0 : 1.0));\n"
"    vec2 aq = p - segment_point(points, npoints, d.z < 0.0 ? 0.0 : 1.0);\n"
"    float ts = dot(aq, dir);\n"
"    if (d.z < 0.0 ? ts < 0.0 : ts > 0.0) {\n"
"        float pseudo_distance = cross_(aq, dir);\n"
"        if (abs(pseudo_distance) <= abs(d.x)) {\n"
"            d.x = pseudo_distance;\n"
"            d.y = 0.0;\n"
"        }\n"
"    }\n"
"    return d.xy;\n"
"}\n"
"\n"
"void add_segment_true_distance(int segment_index, int npoints, int points, vec3 d) {\n"
"    bool is_less = less(d.xy, ws.segments[segment_index].min_true.xy);\n"
"    ws.segments[segment_index].min_true =\n"
"        is_less ? d : ws.segments[segment_index].min_true;\n"
"\n"
"    ws.segments[segment_index].nearest_points =\n"
"        is_less ? points : ws.segments[segment_index].nearest_points;\n"
"    ws.segments[segment_index].nearest_npoints =\n"
"        is_less ? npoints : ws.segments[segment_index].nearest_npoints;\n"
"}\n"
"\n"
"\n"
"void add_segment_pseudo_distance(int segment_index, vec2 d) {\n"
"    int i = d.x < 0.0 ? IDX_NEGATIVE : IDX_POSITIVE;\n"
"    vec2 _d = ws.segments[segment_index].mins[i];\n"
"    ws.segments[segment_index].mins[i] = less(d, _d) ? d : _d;\n"
"}\n"
"\n"
"bool point_facing_edge(int prev_npoints, int prev_points, int cur_npoints, int cur_points,\n"
"                       int next_npoints, int next_points, vec2 p, float param) {\n"
"\n"
"    if (param >= 0.0 && param <= 1.0)\n"
"        return true;\n"
"\n"
"    vec2 prev_edge_dir = -normalize(segment_direction(prev_points, prev_npoints, 1.0));\n"
"    vec2 edge_dir =\n"
"        normalize(segment_direction(cur_points, cur_npoints, param < 0.0 ? 0.0 : 1.0)) *\n"
"        (param < 0.0 ? 1.0 : -1.0);\n"
"    vec2 next_edge_dir = normalize(segment_direction(next_points, next_npoints, 0.0));\n"
"    vec2 point_dir = p - segment_point(cur_points, cur_npoints, param < 0.0 ? 0.0 : 1.0);\n"
"    return dot(point_dir, edge_dir) >=\n"
"           dot(point_dir, param < 0.0 ? prev_edge_dir : next_edge_dir);\n"
"}\n"
"\n"
"float compute_distance(int segment_index, vec2 point) {\n"
"\n"
"    int i = ws.segments[segment_index].min_true.xy.x < 0.0 ? IDX_NEGATIVE : IDX_POSITIVE;\n"
"    float min_distance = ws.segments[segment_index].mins[i].x;\n"
"\n"
"    if (ws.segments[segment_index].nearest_points == -1) return min_distance;\n"
"    vec2 d = distance_to_pseudo_distance(ws.segments[segment_index].nearest_npoints,\n"
"                                         ws.segments[segment_index].nearest_points,\n"
"                                         ws.segments[segment_index].min_true, point);\n"
"    min_distance = abs(d.x) < abs(min_distance) ? d.x : min_distance;\n"
"\n"
"    return min_distance;\n"
"}\n"
"\n"
"vec3 signed_distance_linear(vec2 p0, vec2 p1, vec2 origin) {\n"
"    vec2 aq = origin - p0;\n"
"    vec2 ab = p1 - p0;\n"
"    float param = dot(aq, ab) / dot(ab, ab);\n"
"    vec2 eq = (param > .5 ? p1 : p0) - origin;\n"
"    float endpoint_distance = length(eq);\n"
"    if (param > 0.0 && param < 1.0) {\n"
"        float ortho_distance = dot(orthonormal(ab), aq);\n"
"        if (abs(ortho_distance) < endpoint_distance)\n"
"            return vec3(ortho_distance, 0, param);\n"
"    }\n"
"    return vec3(sign(cross_(aq, ab)) *endpoint_distance,\n"
"                abs(dot(normalize(ab), normalize(eq))),\n"
"                param);\n"
"}\n"
"\n"
"vec3 signed_distance_quad(vec2 p0, vec2 p1, vec2 p2, vec2 origin) {\n"
"    vec2 qa = p0 - origin;\n"
"    vec2 ab = p1 - p0;\n"
"    vec2 br = p2 - p1 - ab;\n"
"    float a = dot(br, br);\n"
"    float b = 3.0 * dot(ab, br);\n"
"    float c = 2.0 * dot(ab, ab) + dot(qa, br);\n"
"    float d = dot(qa, ab);\n"
"    float coeffs[3];\n"
"    float _a = b / a;\n"
"    int solutions;\n"
"\n"
"    float a2 = _a * _a;\n"
"    float q = (a2 - 3.0 * (c / a)) / 9.0;\n"
"    float r = (_a * (2.0 * a2 - 9.0 * (c / a)) + 27.0 * (d / a)) / 54.0;\n"
"    float r2 = r * r;\n"
"    float q3 = q * q * q;\n"
"    float A, B;\n"
"    _a /= 3.0;\n"
"    float t = r / sqrt(q3);\n"
"    t = t < -1.0 ? -1.0 : t;\n"
"    t = t > 1.0 ? 1.0 : t;\n"
"    t = acos(t);\n"
"    A = -pow(abs(r) + sqrt(r2 - q3), 1.0 / 3.0);\n"
"    A = r < 0.0 ? -A : A;\n"
"    B = A == 0.0 ? 0.0 : q / A;\n"
"    if (r2 < q3) {\n"
"        q = -2.0 * sqrt(q);\n"
"        coeffs[0] = q * cos(t / 3.0) - _a;\n"
"        coeffs[1] = q * cos((t + 2.0 * PI) / 3.0) - _a;\n"
"        coeffs[2] = q * cos((t - 2.0 * PI) / 3.0) - _a;\n"
"        solutions = 3;\n"
"    } else {\n"
"        coeffs[0] = (A + B) - _a;\n"
"        coeffs[1] = -0.5 * (A + B) - _a;\n"
"        coeffs[2] = 0.5 * sqrt(3.0) * (A - B);\n"
"        solutions = abs(coeffs[2]) < 1.0e-14 ? 2 : 1;\n"
"    }\n"
"\n"
"    float min_distance = sign(cross_(ab, qa)) * length(qa); // distance from A\n"
"    float param = -dot(qa, ab) / dot(ab, ab);\n"
"    float distance = sign(cross_(p2 - p1, p2 - origin)) * length(p2 - origin); // distance from B\n"
"    if (abs(distance) < abs(min_distance)) {\n"
"        min_distance = distance;\n"
"        param = dot(origin - p1, p2 - p1) / dot(p2 - p1, p2 - p1);\n"
"    }\n"
"    for (int i = 0; i < solutions; ++i) {\n"
"        if (coeffs[i] > 0.0 && coeffs[i] < 1.0) {\n"
"            vec2 endpoint = p0 + ab * 2.0 * coeffs[i] + br * coeffs[i] * coeffs[i];\n"
"            float distance = sign(cross_(p2 - p0, endpoint - origin)) * length(endpoint - origin);\n"
"            if (abs(distance) <= abs(min_distance)) {\n"
"                min_distance = distance;\n"
"                param = coeffs[i];\n"
"            }\n"
"        }\n"
"    }\n"
"    vec2 v = vec2(min_distance, 0.0);\n"
"    v.y = param > 1.0 ? abs(dot(normalize(p2 - p1), normalize(p2 - origin))) : v.y;\n"
"    v.y = param < 0.0 ? abs(dot(normalize(ab), normalize(qa))) : v.y;\n"
"\n"
"    return vec3(v, param);\n"
"}\n"
"\n"
"vec3 get_pixel_distance(vec2 point) {\n"
"    vec3 shape_distance = get_distance(IDX_SHAPE, point);\n"
"    vec3 inner_distance = get_distance(IDX_INNER, point);\n"
"    vec3 outer_distance = get_distance(IDX_OUTER, point);\n"
"    float inner_d = median(inner_distance);\n"
"    float outer_d = median(outer_distance);\n"
"\n"
"    bool inner = inner_d >= 0.0 && abs(inner_d) <= abs(outer_d);\n"
"    bool outer = outer_d <= 0.0 && abs(outer_d) < abs(inner_d);\n"
"    if (!inner && !outer)\n"
"        return shape_distance;\n"
"\n"
"    vec3 d = inner ? inner_distance : outer_distance;\n"
"    vec3 contour_distance = ws.maximums[inner ? IDX_MAX_INNER : IDX_MAX_OUTER];\n"
"\n"
"    float contour_d = median(contour_distance);\n"
"    d = (abs(contour_d) < abs(outer_d) && contour_d > median(d)) ? contour_distance : d;\n"
"\n"
"    contour_distance = ws.min_absolute;\n"
"    contour_d = median(contour_distance);\n"
"    float d_d = median(d);\n"
"\n"
"    d = abs(contour_d) < abs(d_d) ? contour_distance : d;\n"
"    d = median(d) == median(shape_distance) ? shape_distance : d;\n"
"\n"
"    return d;\n"
"}";

const char * _msdf_vertex = "\n"
"layout (location = 0) in vec2 vertex;\n"
"\n"
"precision mediump float;\n"
"uniform mat4 projection;\n"
"uniform vec2 offset;\n"
"\n"
"void main() {\n"
"    gl_Position = projection * vec4(vertex.xy + offset, 1.0, 1.0);\n"
"}";

#endif /* _MSDFGL_SHADERS_H */
